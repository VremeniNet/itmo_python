**ФИО студента:** *Желанов Даниил Вячеславович*  
**Номер группы:** *P4150* 

# Результаты сравнения: рекурсивная vs нерекурсивная генерация бинарного дерева (вариант 4)

**Условия эксперимента**
- Вариант: `left(v) = v * 4`, `right(v) = v + 1`, `root = 4`.
- Сравнивались две реализации построения полного дерева высоты `h`:
  1) **Рекурсивная** (`build_tree_recursive`)
  2) **Нерекурсивная** — BFS с явной очередью (`build_tree_iterative`)
- Измерения: `timeit.repeat(..., number=1)`, в таблицу заносится **медиана** по повторам.
- Контейнер: словарь (`{"value","left","right"}`).
- Ось X на графике — **высота дерева h**, ось Y — **время построения, мс (медиана)**.

---

## Таблица времени (медиана, мс)

|  h | Нерекурсивная | Рекурсивная |
|---:|--------------:|------------:|
|  1 |        0.003  |      0.001  |
|  2 |        0.005  |      0.003  |
|  3 |        0.009  |      0.008  |
|  4 |        0.012  |      0.008  |
|  5 |        0.017  |      0.017  |
|  6 |        0.035  |      0.034  |
|  7 |        0.069  |      0.063  |

**Чистый бенчмарк одного построения** (один вызов, мс; медиана из 15 повторов):
- `h = 5`: нерекурсивная = **0.017** мс, рекурсивная = **0.015** мс  
- Отношение (рекурсивная / нерекурсивная) = **0.88×**

График: `btree_benchmark.png`

---

## Выводы
1. На тестовом окружении **рекурсивная версия чаще немного быстрее** BFS (разница невелика — доли миллисекунды, до ~10–15% при больших `h`), на `h=5` они равны.
2. Оба подхода демонстрируют экспоненциальный рост времени ~O(2^h) из-за количества создаваемых узлов.
3. **Практические соображения**:
   - Рекурсия компактна и понятна, но упирается в лимит глубины стека Python при больших `h`.
   - Нерекурсивная версия (BFS) **устойчива к глубине**, контролирует память и подходит для очень высоких деревьев.
